unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, ExtCtrls, StdCtrls,unit2;

type
  Tkar= array[1..4,1..9] of extended;
  TCards = record
   chislo:byte;{ Шестёрка-туз}
   mast:byte; {Масть карты Пики-Червы}
   vidimost:boolean; {Была ли карта хоть раз показанна}
  end;
  TVer = object
    zn:array[1..4,1..4,1..9] of boolean;
{1-Нулёвка, 2-еденицовка, 3-Немастные 4- парные}
    colzn:array[1..4] of byte;
     vert:array[1..4,1..9] of extended;
     vc:Extended; { вероятностный коэфицент}
    Procedure Init;
    Procedure poslehod;
    Procedure posledobor;
    Procedure vzat;
   end;
  TPodatel = object {Только это податель не пряности а карт.
  Предок игрока, машины, стола и колоды}
        soder:array[1..36] of TCards;
        Buf:TCards;  {Спец Буфер для карт}
        ColKart:byte;
    Procedure Pop(var popc:TCards);
    function rating(i:integer):integer;
  end;
  TColoda = object(TPodatel)
    Procedure Init;
    Procedure Regen;
   end;
   TIgrok = object(TPodatel)
    beru:boolean;
    Procedure Dobor;
    Procedure Hodit(nomer:integer);
   end;
  TMashina = object(TPodatel)
  IMPULSE:array[0..36] of extended; {Импульс для каждой карты и 0 для взятия-побития}
  pogoni:byte;
    Procedure Dobor;
    Procedure Hodit;
    Procedure Bitsa;
    Procedure Element; // Ход по элементарному в конце игры
    Function Cen(Nom:Integer):Extended;
    Function Otn:Extended;
    Procedure Persek(var nad:Tkar);
   end;
  TStol = object(TPodatel)
     bito:boolean;{Эта карта того кто ходит, или того кто бьётся?}
     NCX:Integer;{Начальная координата у карты на столе}
     Procedure ViKlad(const Istochnik:TPodatel);
     procedure Regen;
     Function Cen(var Ist:TMashina):Extended;
   end;
  Tpal = array[1..1024] of byte;
  TForm1 = class(TForm)
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Button4: TButton;
    Label1: TLabel;
    Edit1: TEdit;
    Label2: TLabel;
    Label3: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure FormMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure FormActivate(Sender: TObject);
    procedure FormKeyPress(Sender: TObject; var Key: Char);
    procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
  private
    { Private declarations }
  function vozm(nom:integer):boolean; // Определяет возможность игока пойти.
  public
    { Public declarations }
  end;
Procedure Redraw(y,c:integer;pod:TPodatel; mh:boolean);
Procedure Pobeda(p:byte);
Procedure BitBer(var pod:TPodatel);
Procedure Sortirovka(var pod:TPodatel);
Function GetElem:boolean;
var
  Form1: TForm1;
  karti:array[1..37] of TBitmap;   {Рисунки карт}
  pallete:Tpal;
  col:array[1..256] of Tcolor absolute pallete;
  Prom:array[0..95,-1..70] of byte;
  kozir:byte; {Обьявление козыря}
  panel:boolean;{Включён ли доступ к картам}
  mash:boolean;{Кто ходит человек или машина?}
  beru:boolean;{Когда машина берёт}
  Coloda:TColoda;
  Igrok:TIgrok;
  Mashina:TMashina;
  Stol:TStol;
  Pobito:TPodatel;
  ver:Tver;
  Int,NewInt:array[1..23] of extended;
  report:text;
{Инт- Интеллект, т.н. коэфициэнты самообучения. И вот что
они обозначают:
1-4 когда враг берёт. Тогда
 1- Он берёт потому что нечем бить
 2- Есть карта этого достоинства
 3- Сколько раз подкладывали простую карту
 4- А склоько могли подложить
 5- Сколько раз подложили козырную карту
 6-14 Сами карты, т.е их вес
 15 Если карта -козырь, то вес множится
 16 А  сколько раз могли эту козырную карту подложить
 17 Коэфицент для степени хотения побится/дать   /Возможно пойдёт в резерв.
 18 Коэфицент умножения для этой степени  чтобы дать  и побить
 19 Множитель для самообучения. Первоночально 10%
 20 Важность боязни подклада
 21 Важность тактической ценности
 22 Число, сколько раз были изменения
 23 Степень которая определяет как количесво карт на столе влияет на ценность группы
 }
  wer1,wer2,wer3:  extended;
  {
  1- Вероятность того, что у игрока нет карты этой масти  /Вероятность добровольного взятия
  2- Вероятность того что у игрока уже есть карта этого достоинства в доле./ И принудительного
  3-Степень, определяющая насколько вес карты заставляет игрока подумать, что
  это ценная карта. / Нет, эта степень заставляет игрока удержать у себя эту карту а не ходить её в зависимости от её веса.
  Инициализируются  в TVer.Init
  Она связывает вес карты с вероятностью  того, что её возьмут за то, что
  она ценная.
  (Вес) в степени wer3 - эта вероятность
  }

  VsInt:array[1..6] of extended;
{ Вспомогательные переменные
 1 - Сколько раз машина брала добровольно
 2 - Сколько раз принудительно
 3 - Сколько раз игрок брал добровольно
 4 - Сколько раз принудительно
 5 - Сколько карт максимально добровольно взял игрок.
 6 - Сколько у игрока видимых карт
}
  verotl:boolean;
  otkrKart:boolean;
  elem:boolean;
  {
  Переход в режим элементарной игры, когда можно очевидно
  выиграть.
  }
  bopod:boolean;
  {
  Определяет, когда именно боязнь подклада заставляет машину
  взять.
  }
implementation

{$R *.dfm}


//-------------------------------------------------------------
{Исскуственный интеллект}
//Самообучение
//1. Вес карты
Procedure vesob;
 begin
   if stol.soder[stol.ColKart].mast=Kozir
  then
  newint[15]:=newint[15]+1/3
  else
  newint[stol.soder[stol.ColKart].chislo+5]:=newint[stol.soder[stol.ColKart].chislo+5]+1;
  newint[22]:=newint[22]+1;
 end;
//Теория вероятностей
Procedure TVer.Init;//Обнулить вероятности
var i,j,k:Integer;
 begin
  for i:=1 to 4 do
  begin
   colzn[i]:=0;
   for j:=1 to 4 do
    for k:=1 to 9 do
     zn[i,j,k]:=false;
  end;
  wer1:=int[1]/(Int[1]+Int[2]);
  wer2:=int[2]/(Int[1]+int[2]);
  //wer3:=ln(int[4]/int[3])*ln(int[15]);
  wer3:=ln((int[4]*int[5])/(int[3]*int[16]))/ln(int[15]/int[6]);
  {вероятность=вес^wer3 -> вероянт коз/вер. пр = (вес коз./вес прост)^wer3
   int[4]/int[3]=int[15]^wer3}
 end;
Procedure TVer.PosleHod;//Перерасчёт вероятностей после хода
var i,j:integer; vcc:extended; {Vk- количество видимых карт у игрока}
kn,kv:integer; // Количество карт с повышенной и пониженной вероятностью
kun,kuv:extended; //Коэфициэнт умножения для пониженной и повышенной вероятности.
  begin
if Coloda.ColKart>1 then vc:=(Igrok.ColKart-VsInt[6])/((coloda.ColKart-1)+(Igrok.ColKart-VsInt[6]))
else  vc:=1;  {Насильно в конце обнуляем вероятности}
{if vc>0.6 then
asm
nop
end;  }
    kn:=0;
    kv:=0;
    for i:=1 to 4 do
     for j:=1 to 9 do
      begin

       if (not zn[1,i,j]) and ( not zn[2,i,j]) then
        if zn[3,i,j] then
         begin
          kn:=kn+1;
         end
        else kv:=kv+1;
      { if zn[4,i,j] then vcc:=vcc*(1+wer2)
       else vcc:=vcc*(1-(colzn[4]/(36-colzn[1]-colzn[2]-colzn[4]))*wer2);}

      end;
     if kv=0 then
      begin
       kuv:=1;
       kun:=1;
      end
     else
      begin
       kuv:=1+wer1*kn/kv;
       kun:=1-wer1;
      end;
     for i:=1 to 4 do
      for j:=1 to 9 do
       begin
        if zn[3,i,j] then vcc:=vcc*kun
        else vcc:=vc*kuv;
         vert[i,j]:=vcc;
        if zn[1,i,j]=true then Vert[i,j]:=0;
        if zn[2,i,j]=true then Vert[i,j]:=1;
       end;
  end;
Procedure TVer.PosleDobor;
var j,k:integer;
 begin
  colzn[3]:=0;
  for j:=1 to 4 do
    for k:=1 to 9 do
     zn[3,j,k]:=false;
 end;
Procedure TVer.vzat; //Взял, вероятнее всего, игрок
var koef:extended;
i:integer;flag,flag2:Boolean;
 begin
  with stol do
  begin
 if soder[ColKart].mast=Kozir then koef:=int[15] //Новодел
 else koef:=1;
{ if zn[2,Soder[ColKart].mast,Soder[ColKart].chislo] then wer1:=0 else
  wer1:=1-wer2-
  (
    int[3]+int[4]
  )            *exp(
                     ln(int[soder[ColKart].chislo+5]*koef/int[5])
                    *wer3
                    )/(
                            Int[1]+int[2]+int[3]+int[4]
                            );  }                                         ;
  for i:=soder[colKart].chislo to 9 do
   zn[3,Soder[ColKart].mast,i]:=true;
  end;
   With igrok do
    begin
     flag:=false;
     for i:=1 to ColKart do
      if (soder[i].mast=stol.soder[Stol.ColKart].mast) and (soder[i].chislo<stol.soder[Stol.COlKart].chislo) then flag:=true;
    { if flag then
      begin
       Newint[1]:=Newint[1]+1;
      end; }
      flag2:=false;
      for i:=1 to ColKart do
      if soder[i].chislo=stol.soder[stol.ColKart].chislo then flag2:=true;
  {   if flag2 then Newint[2]:=Newint[2]+1;    }
     {if (flag=false) and (flag2=false) then
      if stol.soder[stol.ColKart].mast=Kozir then NewInt[4]:=NewInt[4]+1
      else newint[3]:=newint[3]+1; }
     newint[22]:=newint[22]+1;
    end;
 end;


//-----------------------------------------------
{Интерфейс}
{Показывать карты}
Procedure VivodKarti(vc:TCards; x,y:integer);
 begin
  Form1.Canvas.Draw(x,y,karti[(vc.mast-1)+4*(vc.chislo-1)+1]);
 end;
Procedure VivodOblojki(x,y:integer);
 begin
  Form1.Canvas.Draw(x,y,karti[37]);
 end;

//Податель карт
procedure TPodatel.Pop(var popc:TCards);
 begin
  popc:=soder[ColKart];
  ColKart:=ColKart-1;
 end;
function TPodatel.Rating; {Для сортировки карт по мастям}
 begin
  if i=0 then rating:=9*(buf.mast)+buf.chislo
  else
   rating:=9*(soder[i].mast)+soder[i].chislo;
 end;
//Колода
procedure TColoda.Regen;
var fs:TRect; i:integer;
 begin
  fs.Top:=200;
  fs.Left:=590;
  fs.Right:=780;
  fs.Bottom:=310;
  form1.Canvas.FillRect(fs);
If colKart>0 then
begin
VivodKarti(soder[1],590,200);
 For i:=0 to (colkart div 4) do VivodOblojki(693+i,200+i);
end;
end;
Procedure TColoda.Init;
var a1:array[1..36] of integer;
    a2:array[1..36] of byte;
i,j,maxn:Integer;
 begin
  Randomize;
   for i:=1 to 36 do  a1[i]:=Random(2000000000)+1;
   for i:=1 to 36 do
    begin
     maxn:=1;
      for j:=2 to 36 do if a1[maxn]<a1[j] then maxn:=j;
     a2[i]:=maxn;
     a1[maxn]:=0;
    end;
   for i:=1 to 36 do
    begin
     soder[i].mast:=((a2[i]-1) mod 4)+1;
     soder[i].chislo:=((a2[i]-1) div 4)+1;
     soder[i].vidimost:=False;
    end;
   soder[1].vidimost:=True;
  regen;
 ColKart:=36;
 end;
//Игрок
procedure TIgrok.Dobor;
var i:integer;
 begin
  if Colkart<6 then
   begin
    for i:=1 to 6-ColKart do
     begin
      if Coloda.ColKart=0 then break
       else
        begin
         ColKart:=ColKart+1;
         Coloda.Pop(Soder[ColKart]);
         if soder[ColKart].vidimost then ver.zn[2,soder[ColKart].mast,soder[colkart].chislo]:=True;
        end;
     end;
   ver.posledobor;
   end;
  sortirovka(igrok);
  redraw(330,ColKart,igrok,false);
 end;
Procedure TIgrok.Hodit(nomer:integer);
 begin
 if not igrok.beru then write(report,'Игрок:',#13,#10);
  if (stol.ColKart>0) and (not mash) then
   if soder[nomer].chislo<>stol.soder[1].chislo then
    if soder[nomer].mast=kozir then newint[5]:=newint[5]+1
    else newint[3]:=newint[3]+1;
  buf:=soder[ColKart];
  soder[ColKart]:=soder[nomer];
  soder[nomer]:=buf;
  ver.zn[1,soder[ColKart].mast,soder[colkart].chislo]:=True;
  stol.ViKlad(Igrok);
  sortirovka(Self);
  redraw(330,ColKart,Igrok,false);
  If mash then
   begin
    vesob;
    if elem then mashina.Element
    else mashina.Hodit;
   end
   else mashina.Bitsa;
 end;
//Машина
procedure TMashina.Dobor;
var i:integer;
 begin
  if colkart<6 then
   begin
    for i:=1 to 6-ColKart do
     begin
      if Coloda.ColKart=0 then break
       else
        begin
         ColKart:=ColKart+1;
         Coloda.Pop(Soder[ColKart]);
          ver.zn[1,soder[ColKart].mast,soder[colkart].chislo]:=True;
        end;
     end;
   end;
  redraw(30,ColKart,Mashina,not otkrkart);
 end;
procedure TMashina.Hodit; //Машина ходит
var i,t,max:integer; rkk:extended; flag:boolean;
 begin
  write(report,'Машина:( карт у машины-:',colkart,#13,#10);
//Блок вычита ценности карт+Надежда выбить хор. карту+Хочется завалить
  if (Stol.ColKart=12)  or (Igrok.ColKart=0) then
  begin
  mash:=false;
  Bitber(Pobito);
  exit;
  end;
  impulse[0]:=-exp(ln(Otn)*int[17])*int[18];
  for i:=1 to ColKart do
   begin
    impulse[i]:=-cen(i);
    {if soder[i].chislo<9 then
     for t:=soder[i].chislo+1 to 9 do
      begin
       rkk:=(
            int[3]+int[4]
            )*exp(
                          ln(int[t+5]/int[5])
                         *wer3                                      //Вероятность
                         )/(                                        // что
                                  Int[1]+int[2]+int[3]+int[4]       // не положут
                                 );
       impulse[i]:=impulse[i]+(1-rkk)*int[16]*int[t+5]*ver.vert[soder[i].mast,t];
       rkk:=rkk*exp(ln(int[15])*wer3);
       if soder[i].mast<>Kozir then
        impulse[i]:=impulse[i]+(1-rkk)*int[16]*int[t+5]*int[15]*ver.vert[kozir,t];
      end; } //Странный блок вероятно занимается выбиванием хорошей карты
   end;
//Блок вычёркивания невозможных альтернатив
  if stol.ColKart=0 then
   t:=1
  else
   begin
    for i:=1 to ColKart do
      begin
       flag:=false;
        for t:=1 to Stol.ColKart do
         if Stol.soder[t].chislo=soder[i].chislo then flag:=true;
       If not flag then impulse[i]:=-1.00e+1000;
      end;
    t:=0;
   end;
//Сам ход
  max:=t;
  for i:=t to ColKart do
   if impulse[i]>impulse[max] then max:=i;
  if max=0 then
   If Igrok.beru then exit
   else
    begin
     mash:=false;
     BitBer(Pobito);
    end
  else
   begin
    buf:=soder[ColKart];
    soder[ColKart]:=soder[max];
    soder[max]:=buf;
    stol.ViKlad(Mashina);
    redraw(30,ColKart,Mashina,not otkrkart);
   end;
 end;
Procedure TMashina.Bitsa;
var i,t,max:integer;  flag:boolean; svesig,svesmash:extended;
bitti: array[1..4] of byte;  {Сколько раз подкладывали кату той или иной масти}
bop: array[1..36] of extended;  {Боязнь подклада той или иной карты}
//rkk:extended;
verud:extended; //Вероятность удержания игроком карты от подклада.
//veroiatn:extended; // Вероятность нахождения карты на руках у игрока.
 begin
   write(report,'Машина:',#13,#10);
   bopod:=false;
//Блок вычита ценности карт-Боязнь что накладут+Хочется отбится
  if (Coloda.ColKart=0)  and (Igrok.ColKart=0) then
   begin
    flag:=false;
    if Colkart=1 then
     begin
      if soder[1].mast=stol.soder[stol.colkart].mast  then
         if  soder[1].chislo<=stol.soder[stol.ColKart].Chislo then
         else
          begin
            flag:=true; // А может и есть?
          end
        else
         if soder[1].mast=Kozir then
          begin
           flag:=true; // Точно есть!
          end
         else  flag:=false;
     end;
     if flag then
      begin
       buf:=soder[ColKart];
       soder[ColKart]:=soder[max];
       soder[max]:=buf;
       stol.ViKlad(Mashina);
      end;
    exit;
   end;
  if beru then exit;
  impulse[0]:=stol.cen(Mashina)-exp(ln(Otn)*int[17])*int[18];
  for i:=1 to ColKart do
   begin
    impulse[i]:=-cen(i); //Изначально импульс равен - ценности карты.
    flag:=False;
//Боязнь что подкладут
    {for t:=1 to stol.ColKart do
     begin
      if stol.soder[t].chislo=soder[i].chislo then flag:=true;
     end;  Возможно неверно, т.к ещё могут подложить}
    //if not flag then
    bop[i]:=0;
     for t:=1 to 4 do
      begin
  {     rkk:=(
            int[3]+int[4]
            )*exp(
                         ln(int[t+5]/int[5])
                        *wer3
                        )/(
                                 Int[1]+int[2]+int[3]+int[4]
                                );  }

          // verud:=(вес карты/ вес 6 прост.)^wer3
       if t<>Kozir then
       // bop[i]:=(1-rkk)*int[20]*int[soder[i].chislo+5]*ver.vert[t,soder[i].chislo];
       // impulse[i]:=impulse[i]-bop[i];
         verud:=exp(ln(int[soder[i].chislo+5]/int[6])*wer3)  //Cчитается что 6 некозырную подложат с вер. 1.

       else
        begin
         verud:=exp(ln(int[soder[i].chislo+5]*int[15]/(int[6]*int[6]))*wer3); //Cчитается что 6 некозырную подложат с вер. 1.
        // rkk:=rkk*exp(ln(int[15])*wer3);
        // bop[i]:=(1-rkk)*int[20]*int[soder[i].chislo+5]*ver.vert[t,soder[i].chislo];
         //impulse[i]:=impulse[i]-bop[i];
        end;
         bop[i]:=bop[i]+int[20]*(1-verud)*ver.vert[t,soder[i].chislo];  //Текущая боязнь+ Важность боязни подклада*Вероятность что карту подкладут*Вероятность, что она вообще есть
      end;
  impulse[i]:=impulse[i]-bop[i];
   end;
//Блок вычёркивания невозможных альтернатив
  flag:=false; { У нас нет карт, чтобы побиться}
  for i:=1 to ColKart do
      begin
        if soder[i].mast=stol.soder[stol.colkart].mast  then
         if  soder[i].chislo<=stol.soder[stol.ColKart].Chislo then
            Impulse[i]:=-1.00e+1000
         else
          begin
           impulse[i]:=Impulse[i];
            flag:=true; // А может и есть?
          end
        else
         if soder[i].mast=Kozir then
          begin
           Impulse[i]:=Impulse[i];
           flag:=true; // Точно есть!
          end
         else  Impulse[i]:=-1.00e+1000;
      end;
//Сам ход
  max:=1;
  { rkk:=-8.9884884114e+11-3.6854775808e-1708;}
   for i:=1 to ColKart do
    if impulse[i]>impulse[max] then max:=i;
   if impulse[0]>impulse[max] then
    begin
    verud:=impulse[max]+bop[max];
   { form1.Label1.Visible:=true;
    form1.Label1.Caption:=floattostr(rkk);}
     if verud>impulse[0] then bopod:=true;
     max:=0;
    end;

  If max=0 then
   begin
    beru:=true;
    Form1.label3.Visible:=True;
    form1.Button3.Caption:='Бери!';
    vesob;
     if flag then    {Если флаг, то взятие добровольное}
       begin
        Vsint[1]:=Vsint[1]+1;
       { for i:=1 to ((Stol.Colkart div 2) +1) do
        if stol.soder[i].chislo<>stol.soder[1].chislo then
         begin
          NewInt[20]:=Newint[20]*(1+Newint[19]);
          break;
         end;  Пока отменяется}
        if bopod then
         begin
          NewInt[20]:=Newint[20]/(1+Newint[19]);
          newint[22]:=newint[22]+1;
         end;
       end
     else
      begin
       svesig:=0;
       svesmash:=0;
        for i:=1 to 4 do
         bitti[i]:=0;
       vsint[2]:=Vsint[2]+1;
        for i:=1 to igrok.ColKart do
         if igrok.soder[i].mast=kozir then
          svesig:=svesig+int[15]*int[igrok.soder[i].chislo+5]
         else
          svesig:=svesig+int[igrok.soder[i].chislo+5];
        svesig:=svesig/igrok.ColKart;
        for i:=1 to ColKart do
         if soder[i].mast=kozir then
          svesmash:=svesmash+int[15]*int[soder[i].chislo+5]
         else
          svesmash:=svesmash+int[soder[i].chislo+5];
        svesmash:=svesmash/ColKart;
       if svesmash>svesig then NewInt[21]:=Newint[21]*(1+Newint[19]);
       for i:=1 to ((Stol.Colkart div 2) +1) do
        if stol.soder[i].chislo<>stol.soder[1].chislo then
         begin
          newint[22]:=newint[22]+1;
          NewInt[20]:=Newint[20]*(1+Newint[19]);
          break;
         end;
       for i:=1 to 4 do
        if bitti[i]>1 then
         begin
           newint[22]:=newint[22]+1;
           NewInt[21]:=Newint[21]/(1+Newint[19]);
           break;
         end;
      end;
   end
  else   // Машина таки ходит а не берёт
   begin
    flag:=true;
    for i:=1 to stol.colkart do
     if stol.soder[i].chislo=soder[max].chislo then flag:=false;
    if flag  then
     begin
      for i:=1 to igrok.Colkart do
       if igrok.soder[i].chislo=soder[max].chislo then
        if igrok.soder[i].mast=kozir then newint[16]:=newint[16]+1
        else newint[4]:=newint[4]+1;
     end;
    buf:=soder[ColKart];
    soder[ColKart]:=soder[max];
    soder[max]:=buf;
    stol.ViKlad(Mashina);
    redraw(30,ColKart,Mashina,not otkrkart);
    vesob;
   end;
 end;
Procedure TMashina.Persek;
var i,j,k:integer; nadiojn,verud:extended;
 begin
  for i:=1 to 4 do
     for j:=1 to 9 do
      nad[i,j]:=0;
   for i:=1 to Colkart-1 do // Здесь искать ошибку в случае того, если у мжины 1 или 0 карт.
    begin
     nadiojn:=1;
      for j:=1 to 4 do
       begin
        if j<>Kozir then
         verud:=exp(ln(int[soder[i].chislo+5]/int[6])*wer3)
        else
          verud:=exp(ln(int[soder[i].chislo+5]*int[15]/int[6]*int[6])*wer3);
       nadiojn:=nadiojn*(1-verud*ver.vert[j,soder[i].chislo]);
       end;
      if soder[i].mast=Kozir then
       begin
         for j:=1 to 4 do
          begin
           if j<>Kozir then
            For k:=1 to 9 do
              nad[j,k]:=1-((1-nadiojn)*(1-nad[j,k]));
          end;
       end;
      for j:=1 to soder[i].chislo do
       begin
        nad[soder[i].mast,j]:=1-((1-nadiojn)*1-nad[soder[i].mast,j]);
       end;
    end;
 end;
Function TMashina.Cen(nom:Integer):Extended;   // Определяет ценность 1-й карты на руках у машины.
var v,v2,rkk:extended;
nad:Tkar;
verud,nadiojn:extended;
{
verud- вероятность НЕ удержания карты игроком
nadiojn- Надёжность прикрытия 1-го сектора.
}
{verCen:array[1..4,1..9] of extended;
bolCen:array[1..4,1..9] of word;}
i,j,k:integer;
{ begin
  v:=0;} {V - это вероятность игрока пойти с данной карты}
 begin
    if colkart<2 then
    begin
      Cen:=0; // Надо ли здесь ставить exit?;
      exit;
    end;
    buf:=soder[nom];
    soder[nom]:=soder[colkart];
    soder[colkart]:=buf;
    colkart:=colkart-1;
    persek(nad);  //Надёжность 1-го сектора
    colkart:=colkart+1;
 //Теперь  будем вычислять ценность
  v2:=0;
   nadiojn:=1; //Надёжность - вероятность того, что на карту не будет подклада, т.е. она успешно отобъёт удар.
      for j:=1 to 4 do
       begin
        if j<>Kozir then
         verud:=exp(ln(int[soder[colkart].chislo+5]/int[6])*wer3)
        else
          verud:=exp(ln(int[soder[colkart].chislo+5]*int[15]/(int[6]*int[6]))*wer3);
       nadiojn:=nadiojn*(1-verud*ver.vert[j,soder[colkart].chislo]);
       end;
      if soder[colkart].mast=Kozir then //Считаем сколько карт козырь может убить.
       begin
         for j:=1 to 4 do
          begin
           if j<>Kozir then
            For k:=1 to 9 do
             begin
              verud:=exp(ln(int[k+5]/int[6])*wer3); //Вероятность, что карта которую козырь может убить вообще положат
              v2:=v2+nadiojn*(1-nad[j,k])*ver.vert[j,k]*(1-verud);
             end; 
          end;
       end;
      for j:=1 to soder[colkart].chislo do
       begin
         if soder[colkart].mast<>Kozir then
          verud:=exp(ln(int[j+5]/int[6])*wer3)
         else
          verud:=exp(ln(int[j+5]*int[15]/(int[6]*int[6]))*wer3);
         v2:=v2+nadiojn*(1-nad[soder[colkart].mast,j])*ver.vert[soder[colkart].mast,j]*(1-verud);
       end;

 { for i:=1 to  4 do
   for j:=1 to 9 do
    begin }
    { rkk:=(
          int[3]+int[4]
           )       *exp(
                         ln(int[j+5]/int[5])
                        *wer3                                      //Вероятность
                        )/(                                        // что
                                 Int[1]+int[2]+int[3]+int[4]       // не положут
                                );
     if i=Kozir then  rkk:=rkk*exp(ln(int[15])*wer3); }
   //  ------------------  Внедрённый кусок
  {
     //-----------------------
     vercen[i,j]:=ver.vert[i,j]*(1-rkk);
     v:=v+vercen[i,j];
     bolcen[i,j]:=0;  {ОБнуление bolcen на пару с основным действием}
   { end;  }

 { v:=1/v;
  for k:=1 to ColKart do
   if soder[k].chislo=soder[nom].chislo then
    begin
     if soder[k].chislo>1 then
      begin
       for i:=1 to soder[k].chislo-1 do
         bolcen[soder[k].mast,i]:=bolcen[soder[k].mast,i]+1;
      end;
     if  soder[k].mast=Kozir then
      for i:=1 to 4 do
       if i<>Kozir then
        for j:=1 to 9 do
           bolcen[i,j]:=bolcen[i,j]+1;
     end;
   v2:=0;
   for i:=1 to 4 do
    for j:=1 to 9 do
     begin
      v2:=v2+vercen[i,j]*v*bolcen[i,j]
     end; }
  If soder[nom].mast=Kozir then v:=int[15]/int[6] else v:=1;
  soder[colkart]:=soder[nom];
  soder[nom]:=buf;
  cen:=(v2*int[21]+int[soder[nom].chislo+5]*v/int[6])//Тактическая ценность +Статегичесая
 end;

Function TMashina.Otn:Extended;
Var c:Integer;
 begin
  If mash then c:=0
  else
    if igrok.ColKart<6 then
     if Coloda.ColKart<(6-igrok.ColKart) then c:=Coloda.ColKart
       else  c:=6-igrok.ColKart
    else c:=0;
   If Igrok.ColKart+c=0 then otn:=100000000 else
  Otn:=(ColKart+Stol.ColKart)/(Igrok.ColKart+c);
 end;

Procedure TMashina.Element;
 var i,j:byte;
 primet:byte; // Какая карта на примете у машины чтобы пойти
 begin
  write(report,'В элементарном режиме:( карт у машины-:',colkart,#13,#10);
  if stol.ColKart>0 then
   begin
    for i:=1 to ColKart do
     begin
      if soder[i].chislo=stol.soder[1].chislo
       then
        begin
         buf:=soder[ColKart];
         soder[ColKart]:=soder[i];
         soder[i]:=buf;
         stol.ViKlad(Mashina);
         exit;
        end;
     end;
    if not (igrok.beru) then
       begin
          mash:=false;
          BitBer(Pobito);
       end;
   end
  else
  begin
  primet:=0;
  for i:=1 to 9 do
   begin
    if i<>pogoni then
     begin
      for j:=1 to colkart do
       begin
        if soder[j].chislo=i then
         if soder[j].mast=kozir then
         begin
         primet:=0;
         break;
         end
         else primet:=j;
       end;
     end;
    if primet<>0 then break
   end;
   if primet=0 then
    for i:=1 to 9 do
   begin
    if i<>pogoni then
     begin
      for j:=1 to colkart do
       begin
        if soder[j].chislo=i then
          primet:=j;
       end;
     end;
     if primet<>0 then break
   end;
    if primet<>0 then
     begin
      buf:=soder[ColKart];
      soder[ColKart]:=soder[primet];
      soder[primet]:=buf;
      stol.ViKlad(Mashina);
     end
    else
     if ColKart>0 then
      stol.ViKlad(Mashina)
      else
       if not (igrok.beru) then
       begin
          mash:=false;
          BitBer(Pobito);
       end;
   end;
 end;
//Карточный стол
procedure TStol.Regen;
Var I:Integer;
 begin
  bito:=false;
  NCX:=-63;
  If ColKart>0 then
   for i:=1 to ColKart do
    begin
      If bito=false then
    begin
     bito:=true;
     NCX:=NCX+68;
    end
   else
    begin
     bito:=false;
     NCX:=NCX+23;
    end;
      VivodKarti(soder[i],NCX,200);
    end;
 end;
Procedure TStol.Viklad(const Istochnik:TPodatel);
 begin
    ColKart:=ColKart+1;
   Istochnik.Pop(soder[ColKart]);
   soder[colKart].vidimost:=true;
   Regen;
   write(report,soder[colkart].chislo+5,'-',
   soder[colkart].mast,#13,#10);
 end;
Function TStol.Cen(var Ist:TMashina):Extended;
Var v,v2,nadiojn,verud:extended; i,j,k:integer;  nad:Tkar;
 begin
{   v:=0;
   for i:=1 to ColKart do
    begin
     Ist.ColKart:=Ist.ColKart+1;
     Ist.soder[Ist.ColKart]:=soder[i];
     v:=v+ist.cen(Ist.ColKart);
    end;
   Ist.ColKart:=Ist.ColKart-ColKart; }
  ist.Persek(nad);
  v2:=0;
  v:=0;
  for i:=1 to colkart do
   begin
   nadiojn:=1;

      for j:=1 to 4 do
       begin
        if j<>Kozir then
         verud:=exp(ln(int[soder[i].chislo+5]/int[6])*wer3)
        else
          verud:=exp(ln(int[soder[i].chislo+5]*int[15]/int[6]*int[6])*wer3);
       nadiojn:=nadiojn*(1-verud*ver.vert[j,soder[i].chislo]);
       end;
      if soder[i].mast=Kozir then
       begin
         for j:=1 to 4 do
          begin
           if j<>Kozir then
            For k:=1 to 9 do
             begin
              verud:=exp(ln(int[k+5]/int[6])*wer3);
              v2:=v2+nadiojn*(1-nad[j,k])*ver.vert[j,k]*(1-verud);
              nad[j,k]:=1-((1-nadiojn)*(1-nad[j,k]));
             end;
          end;
       end;
      for j:=1 to soder[i].chislo do
       begin
         if soder[i].mast<>Kozir then
          verud:=exp(ln(int[j+5]/int[6])*wer3)
         else
          verud:=exp(ln(int[j+5]*int[15]/int[6]*int[6])*wer3);
         v2:=v2+nadiojn*(1-nad[soder[i].mast,j])*ver.vert[soder[i].mast,j]*(1-verud);
       end;
     if soder[i].mast=kozir then  v:=v+(int[15]/int[6])*int[soder[i].chislo+5]
     else  v:=v+int[soder[i].chislo+5];
   end;

 Cen:=v/exp(ln(ColKart)*Int[23])+v2*int[21];
 end;
//Просто процедуры
Function GetElem:boolean;
 var i,j,k,pogoni:byte; chk,chk1:byte; // Число козырей  у игрока
 pris,koz,vsa:boolean; //Признак: у машины есть карты этой масти, они козыри, игрок берёт
 begin
   pogoni:=0;
   chk:=0;
   for i:=1 to igrok.ColKart do
     if igrok.soder[i].mast=kozir then chk:=chk+1;
   for i:=1 to 9 do
    begin
      chk1:=chk;
      vsa:=false;
      koz:=false;
      pris:=false;
      for j:=1 to Mashina.ColKart do
       begin
        if mashina.soder[j].chislo=i then
         begin
          if  mashina.soder[j].mast=kozir then
           begin
            vsa:=false;
              for k:=1 to igrok.ColKart do
               if (igrok.soder[k].mast=mashina.soder[j].mast) and
             (igrok.soder[k].chislo>mashina.soder[j].chislo) then
               koz:=true;
             if koz=false then vsa:=true;
           end
          else
           begin
            vsa:=true;
            for k:=1 to igrok.ColKart do
             if (igrok.soder[k].mast=mashina.soder[j].mast) and
              (igrok.soder[k].chislo>mashina.soder[j].chislo) then
                vsa:=false;
            if vsa then
             begin
              if chk1>0 then
               begin
                chk1:=chk1-1;
                vsa:=false;
               end;
             end;
           end;
          Pris:=true;
         end;
        if vsa or koz then break;
       end;
      if (not vsa) and (pris)  then
       begin
        if pogoni=0 then pogoni:=i
        else
         begin
          Getelem:=false;
          exit;
         end;
       end;
    end;
  mashina.pogoni:=pogoni;
  Getelem:=true;
 end;
Procedure Redraw(y,c:integer;pod:TPodatel;mh:boolean);
var fs:TRect; i:integer;
 begin
  fs.Top:=y;
  fs.Left:=1;
  fs.Right:=600;
  fs.Bottom:=y+100;
  form1.Canvas.FillRect(fs);
 If mh
  then
    begin
    for i:=1 to c do
    vivodOblojki(20+(500 div c)*(i-1),y);
    end
  else
  for i:=1 to c do
    vivodkarti(pod.soder[i],20+(500 div c)*(i-1),y);
 end;
procedure NachHod;{Начинаем ход}
var i:integer; pob:byte;{опред кто победил}
begin
  write(report,'Начало хода( карт у машины-:',mashina.colkart,#13,#10);
 pob:=0;
 beru:=false;
 igrok.beru:=false;
 Form1.label3.Visible:=false;
 form1.Button3.Caption:='Бито!';
 if mash then
  begin
   Mashina.Dobor;
   Igrok.Dobor;
   form1.Button3.Visible:=False;
   form1.Button4.Visible:=True;
  end
 else
  begin
   Igrok.Dobor;
   Mashina.Dobor;
   form1.Button3.Visible:=True;
   form1.Button4.Visible:=False;
  end;
  stol.bito:=false;
  stol.NCX:=-83;
  redraw(200,0,Stol,true);
  coloda.Regen;
  If (coloda.colkart=0) and (mash) then elem:=Getelem;
  If igrok.colkart=0 then pob:=pob or 1;
  If mashina.colkart=0 then   pob:=pob or 2;
  If pob>0 then begin pobeda(pob); exit; end;
 VsInt[6]:=0;
  for i:=1 to Igrok.ColKart do
     if Igrok.soder[i].vidimost then Vsint[6]:=Vsint[6]+1;
 ver.poslehod;
 if elem then write(report,'Машина переходит в элементарный режим',#13,#10);
 if mash then
  if elem then  mashina.Element
  else mashina.hodit;
end;
Procedure Sortirovka;{Cортировка карт}
var i,j:integer;  bf2:Tcards;
 begin
   for i:=1 to pod.ColKart do
    begin
     pod.Buf:=pod.soder[i];
     for j:=i+1 to pod.colKart  do
      begin
       if pod.rating(j)<pod.rating(0)
        then
         begin
          bf2:=pod.buf;
          pod.Buf:=pod.soder[j];
          pod.soder[j]:=Bf2;
         end;
      end;
     pod.soder[i]:=pod.Buf;
    end;
 end;
Procedure BitBer(var pod:TPodatel);
var i,j:integer;
 begin
  if stol.ColKart>0 then
   begin
    j:=Stol.ColKart;
    for i:=1 to j do stol.Pop(pod.soder[i+pod.colKart]);
    pod.ColKart:=pod.ColKart+j;
    NachHod;
   end;
 end;
Procedure Pobeda(p:byte);
var
i:integer;
begin
 case p of
  1:
  begin
   form1.Label1.Caption:='Поздравляем вы победитель!';
   form1.Label1.Font.Color:=clred;
   mash:=false;
    for i:=1 to Mashina.ColKart do
     begin
       Stol.ColKart:=1;
       Mashina.Pop(stol.soder[1]);
       vesob;
       Stol.ColKart:=0;
     end;
  end;
  2:
  begin
   form1.Label1.Caption:='Увы,вы проиграли...';
   form1.Label1.Font.Color:=clblue;
   mash:=true;
    for i:=1 to Igrok.ColKart do
     begin
       Stol.ColKart:=1;
       Igrok.Pop(stol.soder[1]);
       vesob;
       Stol.ColKart:=0;
     end;
  end;
   else
    begin
     form1.Label1.Caption:='Ничья!';
     form1.Label1.Font.Color:=clwhite;
     stol.ColKart:=0;
    end;
  end;
 newint[1]:=newint[1]+Vsint[2];
 newint[2]:=newint[2]+Vsint[1];
 if (vsint[1]+1)/(vsint[3]+1)>1 then Newint[18]:=newint[18]*(1+newint[19]);
 if (vsint[2]+1)/(vsint[4]+1)>1 then Newint[18]:=newint[18]/(1+newint[19]);
 if exp(ln(vsint[5]/6)*newint[17])*newint[18]<(1+newint[21])*newint[15]*newint[14]
  then Newint[17]:=Newint[17]*(1+Newint[19]);
 if exp(ln(vsint[5]/6)*newint[17])*newint[18]>2*(1+newint[21])*newint[15]*newint[14]
  then Newint[17]:=Newint[17]/(1+Newint[19]);

 if (newint[22]>1000) and (newint[19]>0.02) then
  begin
   Newint[22]:=0;
   Newint[19]:=Newint[19]/2;
  end;

 form1.Label1.Visible:=true;
 panel:=false;
 form1.Button3.Visible:=false;
 form1.Button4.Visible:=false;
end;

{Загрузка ресурсов}
procedure TForm1.FormCreate(Sender: TObject);
var fil:file; i,x,y:integer; t:byte;
begin
 otkrKart:=false;
 panel:=false;
 mash:=false;
 assignfile(fil,'Cards.crd');
 reset(fil,1);
 blockread(fil,pallete,1024);
 {form2.Show;
 form2.Label1.Visible:=true;}
  for i:=1 to 37 do
   begin
    karti[i]:=TBitmap.Create;
    karti[i].Height:=96;
    karti[i].Width:=71;
    If EOF(fil) then break;
    blockread(fil,prom,72*96);
     for y:=0 to 95 do
      for x:=-1 to 70 do
       begin
         t:=prom[y,x];
        if x<>71 then karti[i].Canvas.Pixels[x,95-y]:=pallete[t*4+1]+$100*pallete[t*4+2]+$10000*pallete[t*4+3];
       end;
    {form2.ProgressBar1.Position:=i-1;}
   end;
  {form2.Close;}
 closefile(fil);
 assignfile(fil,'Durak2.ini');
 reset(fil,10);
 blockread(fil,int,23);
 NewInt:=Int;
  for i:=6 to 15 do
   begin
    int[i]:=int[i]/newint[6]
   end;
 closefile(fil);
 assignfile(report,'report.txt');
 rewrite(report);
end;

procedure TForm1.Button1Click(Sender: TObject);  {Сдать карты}
begin
  label1.visible:=false;
  ELEM:=FALSE;
  VsInt[5]:=7;
  panel:=true;
  Coloda.Init;
  kozir:=coloda.soder[1].mast;
  Igrok.ColKart:=0;
  Mashina.ColKart:=0;
  Ver.Init;
  write(report,'Начало игры:',#13,#10);
  NachHod;

end;
function TForm1.vozm;
var
flag:boolean; t:integer;
 begin
    if mash then
    begin
     if Igrok.soder[nom].mast=stol.soder[stol.colkart].mast  then
         if  Igrok.soder[nom].chislo<=stol.soder[stol.ColKart].Chislo then
            flag:=false
         else flag:=true
        else
         if igrok.soder[nom].mast=Kozir then
          flag:=true
         else flag:=false;
    end
   else
    begin
     if stol.ColKart=0 then
      flag:=true
     else
      begin
       flag:=false;
        for t:=1 to Stol.ColKart do
         if Stol.soder[t].chislo=Igrok.soder[nom].chislo then flag:=true;
      end;
   end;
  vozm:=flag;
 end;
procedure TForm1.FormMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var flag:boolean; nom:integer;
begin
 If (x>20) and (y>330) and (x<600) and (panel=true) and(igrok.ColKart>0) then
  begin
    nom:=(x-20) div (500 div Igrok.ColKart)+1;
    if nom>igrok.ColKart then nom:=igrok.ColKart;
     flag:=vozm(nom);
   if flag then Igrok.Hodit(nom);
  end;
end;

procedure TForm1.Button2Click(Sender: TObject);
begin
 form1.Close;
end;

procedure TForm1.Button3Click(Sender: TObject);
begin
 if stol.ColKart=0 then exit;
 if beru then BitBer(Mashina) else
 begin
 mash:=true;
 BitBer(Pobito);
 end;
end;

procedure TForm1.Button4Click(Sender: TObject);
var i:Integer; flag:boolean;
begin
 write(report,'Игрок забирает',#13,#10);
  vesob;
 flag:=false;
 for i:=1 to Igrok.ColKart do
  begin
     if Igrok.soder[i].mast=stol.soder[stol.colkart].mast  then
         if  Igrok.soder[i].chislo<=stol.soder[stol.ColKart].Chislo then
            flag:=flag
         else flag:=true
        else
         if igrok.soder[i].mast=Kozir then
          flag:=true
         else flag:=flag;
  end;
 if flag then  {Добовольно взял}
  begin
  vsint[3]:=vsint[3]+1;
  VsInt[5]:=Igrok.ColKart+Stol.ColKart;
  end
 else
  begin
   vsint[4]:=vsint[4]+1;
  end;
 igrok.beru:=true;
 for i:=1 to 36 do
  if elem then mashina.Element
   else Mashina.Hodit;
 for i:=1 to Stol.ColKart do
  begin
   ver.zn[1,stol.soder[i].mast,stol.soder[i].chislo]:=false;
   ver.zn[2,stol.soder[i].mast,stol.soder[i].chislo]:=True;
  end;
 Ver.vzat;
 Bitber(igrok);
end;

procedure TForm1.FormActivate(Sender: TObject);    //При перересовкеж
begin
 if otkrkart then redraw(30,Mashina.ColKart,Mashina,false) else redraw(30,Mashina.ColKart,Mashina,true);
redraw(330,Igrok.ColKart,Igrok,false);
coloda.Regen;
stol.Regen;
end;

procedure TForm1.FormKeyPress(Sender: TObject; var Key: Char);
 var flag:boolean;
begin

 case key of
  '1': If igrok.ColKart>=1 then if vozm(1) then Igrok.Hodit(1);
  '2': If igrok.ColKart>=2 then if vozm(2) then Igrok.Hodit(2);
  '3': If igrok.ColKart>=3 then if vozm(3) then Igrok.Hodit(3);
  '4': If igrok.ColKart>=4 then if vozm(4) then Igrok.Hodit(4);
  '5': If igrok.ColKart>=5 then if vozm(5) then Igrok.Hodit(5);
  '6': If igrok.ColKart>=6 then if vozm(6) then Igrok.Hodit(6);
  '7': If igrok.ColKart>=7 then if vozm(7) then Igrok.Hodit(7);
  '8': If igrok.ColKart>=8 then if vozm(8) then Igrok.Hodit(8);
  '9': If igrok.ColKart>=9 then if vozm(9) then Igrok.Hodit(9);
  #5: form1.Edit1.Visible:= not form1.Edit1.Visible; //Ctrl+e -Отладочная строка
  #23:
  begin
   verotl:=not verotl; //Ctrl+w Показывает вероятность для каждой карты
   form1.Label1.Visible:=False;
  end;
  #15:
   begin
    otkrKart:=not otkrKart;   {Ctrl+o Открывает карты компа}
   end;
  #18:
    form1.FormActivate(Form1); {Ctrl+r обновляет экран}
  else form1.Edit1.Text:=inttostr(ord(key));  end;
end;

procedure TForm1.FormMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var pa,mst,chl:word;
begin
  if verotl then
 begin
 pa:=(x-20) div (500 div Igrok.ColKart)+1;
 If (x>20) and (y>330) and (x<600) and (panel=true) and(igrok.ColKart>0) then
   begin
     form1.Label2.Top:=y-20;
     form1.label2.Left:=x+5;
     mst:=igrok.soder[pa].mast;
     chl:=igrok.soder[pa].chislo;
   if ver.zn[1,mst,chl] then
    form1.Label2.Caption:='0'
   else
    if ver.zn[2,mst,chl] then
     form1.Label2.Caption:='1'
    else
     form1.Label2.Caption:=Floattostr(ver.vert[mst,chl]);

     form1.Label2.Visible:=true;
 end
 else
  if (x>600) and (y<330) and (y<200) then
   begin
     form1.Label2.Top:=y-20;
     form1.label2.Left:=x-50;
    form1.Label2.Caption:=Inttostr(Coloda.ColKart)+' Карт осталось';
     form1.Label2.Visible:=true;
   end
  else


  form1.Label2.Visible:=false;
 end;
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
var fil:file of extended;
begin
 closefile(report);
 assignfile(fil,'Durak2.ini');
 rewrite(fil);
 blockwrite(fil,Newint,23);
 closefile(fil);
end;

end.
